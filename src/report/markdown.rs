use super::{ReportGenerator, ReportResult};
use crate::snapshot::format::{Finding, Severity, Snapshot, Category, RiskLevel};
use std::fs::File;
use std::io::Write;
use std::path::Path;
use chrono::Utc;

/// Markdown report generator for file output
pub struct MarkdownReporter {
    include_toc: bool,
    include_recommendations: bool,
    include_evidence: bool,
}

impl MarkdownReporter {
    pub fn new() -> Self {
        Self {
            include_toc: true,
            include_recommendations: true,
            include_evidence: true,
        }
    }

    pub fn with_toc(mut self, include: bool) -> Self {
        self.include_toc = include;
        self
    }

    pub fn with_recommendations(mut self, include: bool) -> Self {
        self.include_recommendations = include;
        self
    }

    pub fn with_evidence(mut self, include: bool) -> Self {
        self.include_evidence = include;
        self
    }

    /// Generate a markdown report and save it to a file
    pub fn save_report(&self, snapshot: &Snapshot, findings: &[Finding], output_path: &Path) -> ReportResult<()> {
        let content = self.generate_markdown(snapshot, findings)?;
        
        let mut file = File::create(output_path)?;
        file.write_all(content.as_bytes())?;
        
        Ok(())
    }

    /// Generate the markdown content
    fn generate_markdown(&self, snapshot: &Snapshot, findings: &[Finding]) -> ReportResult<String> {
        let mut md = String::new();
        
        // Header
        md.push_str("# Kafka Cluster Health Report\n\n");
        md.push_str(&format!("Generated by **KafkaPilot** v{}\n\n", snapshot.metadata.tool_version));
        md.push_str(&format!("üìÖ **Report Date**: {}\n\n", Utc::now().format("%Y-%m-%d %H:%M:%S UTC")));
        
        // Table of Contents
        if self.include_toc {
            md.push_str("## Table of Contents\n\n");
            md.push_str("- [Executive Summary](#executive-summary)\n");
            md.push_str("- [Cluster Information](#cluster-information)\n");
            md.push_str("- [Health Score](#health-score)\n");
            md.push_str("- [Findings Summary](#findings-summary)\n");
            md.push_str("- [Detailed Findings](#detailed-findings)\n");
            if self.include_recommendations {
                md.push_str("- [Recommendations](#recommendations)\n");
            }
            md.push_str("- [Next Steps](#next-steps)\n\n");
        }

        // Executive Summary
        md.push_str("## Executive Summary\n\n");
        let (critical, high, medium, low, info) = self.count_severities(findings);
        let total = findings.len();
        
        if total == 0 {
            md.push_str("‚úÖ **No issues found!** Your Kafka cluster appears to be healthy.\n\n");
        } else {
            md.push_str(&format!("‚ö†Ô∏è **{} issue(s) detected** in your Kafka cluster requiring attention.\n\n", total));
            
            if critical > 0 || high > 0 {
                md.push_str(&format!("üö® **Immediate action required**: {} critical and {} high severity issues found.\n\n", critical, high));
            }
        }

        // Cluster Information
        md.push_str("## Cluster Information\n\n");
        md.push_str("| Property | Value |\n");
        md.push_str("|----------|-------|\n");
        
        if let Some(id) = &snapshot.cluster.id {
            md.push_str(&format!("| **Cluster ID** | `{}` |\n", id));
        }
        if let Some(name) = &snapshot.cluster.name {
            md.push_str(&format!("| **Cluster Name** | {} |\n", name));
        }
        if let Some(version) = &snapshot.cluster.version {
            md.push_str(&format!("| **Kafka Version** | {} |\n", version));
        }
        
        let mode_display = match &snapshot.cluster.mode {
            crate::snapshot::format::ClusterMode::Kraft => "KRaft (modern, Zookeeper-free)",
            crate::snapshot::format::ClusterMode::Zookeeper => "Zookeeper (legacy)",
            crate::snapshot::format::ClusterMode::Unknown => "Unknown",
        };
        md.push_str(&format!("| **Mode** | {} |\n", mode_display));
        if let Some(provider) = &snapshot.cluster.cloud_provider {
            md.push_str(&format!("| **Cloud Provider** | {} |\n", provider));
        }
        if let Some(region) = &snapshot.cluster.region {
            md.push_str(&format!("| **Region** | {} |\n", region));
        }
        md.push_str(&format!("| **Scan Timestamp** | {} |\n", snapshot.timestamp.format("%Y-%m-%d %H:%M:%S UTC")));
        md.push_str(&format!("| **Collection ID** | `{}` |\n", snapshot.metadata.collection_id));
        md.push('\n');

        // Health Score
        md.push_str("## Health Score\n\n");
        let health_score = self.calculate_health_score(findings);
        let score_emoji = if health_score >= 80.0 {
            "üü¢"
        } else if health_score >= 60.0 {
            "üü°"
        } else {
            "üî¥"
        };
        
        md.push_str(&format!("### {} Overall Health: {:.0}/100\n\n", score_emoji, health_score));
        
        // Score breakdown
        md.push_str("**Score Breakdown:**\n\n");
        md.push_str("```\n");
        let bar_length = 50;
        let filled = ((health_score / 100.0) * bar_length as f64) as usize;
        md.push_str(&format!("[{}{}] {:.0}%\n", "‚ñà".repeat(filled), "‚ñë".repeat(bar_length - filled), health_score));
        md.push_str("```\n\n");
        
        // Health interpretation
        let interpretation = if health_score >= 90.0 {
            "Excellent - Cluster is operating optimally"
        } else if health_score >= 80.0 {
            "Good - Minor improvements recommended"
        } else if health_score >= 60.0 {
            "Fair - Several issues need attention"
        } else if health_score >= 40.0 {
            "Poor - Significant issues require immediate attention"
        } else {
            "Critical - Cluster health is severely compromised"
        };
        md.push_str(&format!("**Status**: {}\n\n", interpretation));

        // Findings Summary
        md.push_str("## Findings Summary\n\n");
        
        if total > 0 {
            md.push_str("### Severity Distribution\n\n");
            md.push_str("| Severity | Count | Percentage |\n");
            md.push_str("|----------|-------|------------|\n");
            
            if critical > 0 {
                md.push_str(&format!("| üî¥ **Critical** | {} | {:.1}% |\n", critical, (critical as f64 / total as f64) * 100.0));
            }
            if high > 0 {
                md.push_str(&format!("| üü† **High** | {} | {:.1}% |\n", high, (high as f64 / total as f64) * 100.0));
            }
            if medium > 0 {
                md.push_str(&format!("| üü° **Medium** | {} | {:.1}% |\n", medium, (medium as f64 / total as f64) * 100.0));
            }
            if low > 0 {
                md.push_str(&format!("| üü¢ **Low** | {} | {:.1}% |\n", low, (low as f64 / total as f64) * 100.0));
            }
            if info > 0 {
                md.push_str(&format!("| ‚ÑπÔ∏è **Info** | {} | {:.1}% |\n", info, (info as f64 / total as f64) * 100.0));
            }
            md.push_str(&format!("| **Total** | **{}** | **100%** |\n\n", total));

            // Category breakdown
            md.push_str("### Category Distribution\n\n");
            let categories = self.count_categories(findings);
            
            md.push_str("| Category | Count |\n");
            md.push_str("|----------|-------|\n");
            for (category, count) in categories {
                md.push_str(&format!("| {} | {} |\n", self.format_category(category), count));
            }
            md.push('\n');
        }

        // Detailed Findings
        md.push_str("## Detailed Findings\n\n");
        
        if findings.is_empty() {
            md.push_str("No issues were detected during the analysis.\n\n");
        } else {
            // Group findings by severity
            let mut sorted_findings = findings.to_vec();
            sorted_findings.sort_by_key(|f| f.severity);
            
            for (idx, finding) in sorted_findings.iter().enumerate() {
                self.write_finding(&mut md, idx + 1, finding)?;
            }
        }

        // Recommendations
        if self.include_recommendations && !findings.is_empty() {
            md.push_str("## Recommendations\n\n");
            md.push_str("### Priority Actions\n\n");
            
            let critical_high: Vec<_> = findings.iter()
                .filter(|f| matches!(f.severity, Severity::Critical | Severity::High))
                .collect();
            
            if !critical_high.is_empty() {
                md.push_str("1. **Immediate Actions Required**:\n");
                for finding in critical_high {
                    md.push_str(&format!("   - {}\n", finding.title));
                }
                md.push('\n');
            }
            
            md.push_str("2. **General Recommendations**:\n");
            md.push_str("   - Address all critical and high severity issues immediately\n");
            md.push_str("   - Review and implement remediation steps in a test environment first\n");
            md.push_str("   - Schedule maintenance windows for changes requiring downtime\n");
            md.push_str("   - Monitor cluster metrics after applying fixes\n");
            md.push_str("   - Consider implementing automated monitoring for recurring issues\n\n");
        }

        // Next Steps
        md.push_str("## Next Steps\n\n");
        md.push_str("1. **Review** this report with your team\n");
        md.push_str("2. **Prioritize** fixes based on severity and business impact\n");
        md.push_str("3. **Test** all remediation steps in a non-production environment\n");
        md.push_str("4. **Implement** fixes during scheduled maintenance windows\n");
        md.push_str("5. **Verify** that issues are resolved after applying fixes\n");
        md.push_str("6. **Schedule** regular health checks to prevent future issues\n\n");

        // Footer
        md.push_str("---\n\n");
        md.push_str("*This report was automatically generated by [KafkaPilot](https://kafkapilot.io)*\n");
        md.push_str(&format!("*Report Version: {} | Tool Version: {}*\n", 
                            snapshot.version, snapshot.metadata.tool_version));

        Ok(md)
    }

    fn write_finding(&self, md: &mut String, num: usize, finding: &Finding) -> ReportResult<()> {
        let severity_icon = finding.severity.icon();
        let severity_text = format!("{:?}", finding.severity);
        
        // Finding header
        md.push_str(&format!("### {} Finding #{}: {}\n\n", severity_icon, num, finding.title));
        
        // Metadata table
        md.push_str("| | |\n");
        md.push_str("|---|---|\n");
        md.push_str(&format!("| **Severity** | {} {} |\n", severity_icon, severity_text));
        md.push_str(&format!("| **Category** | {} |\n", self.format_category(finding.category)));
        md.push_str(&format!("| **ID** | `{}` |\n\n", finding.id));
        
        // Description
        md.push_str("#### Description\n\n");
        md.push_str(&format!("{}\n\n", finding.description));
        
        // Impact
        md.push_str("#### Impact\n\n");
        md.push_str(&format!("{}\n\n", finding.impact));
        
        // Root Cause
        if let Some(root_cause) = &finding.root_cause {
            md.push_str("#### Root Cause\n\n");
            md.push_str(&format!("{}\n\n", root_cause));
        }
        
        // Evidence
        if self.include_evidence && (!finding.evidence.metrics.is_empty() || 
                                    !finding.evidence.logs.is_empty() || 
                                    !finding.evidence.configs.is_empty()) {
            md.push_str("#### Evidence\n\n");
            
            // Config evidence
            if !finding.evidence.configs.is_empty() {
                md.push_str("**Configuration Issues:**\n\n");
                for config in &finding.evidence.configs {
                    md.push_str(&format!("- **{}** ({}): Current value: `{}`", 
                                       config.config_key, 
                                       config.resource_name,
                                       config.current_value));
                    if let Some(recommended) = &config.recommended_value {
                        md.push_str(&format!(" ‚Üí Recommended: `{}`", recommended));
                    }
                    md.push('\n');
                    if !config.source_files.is_empty() {
                        md.push_str("  - Affected files:\n");
                        for file in &config.source_files {
                            md.push_str(&format!("    - `{}`\n", file));
                        }
                    }
                }
                md.push('\n');
            }
            
            // Metric evidence
            if !finding.evidence.metrics.is_empty() {
                md.push_str("**Metrics:**\n\n");
                for metric in &finding.evidence.metrics {
                    md.push_str(&format!("- **{}**: {} {}", 
                                       metric.name, 
                                       metric.value,
                                       metric.unit.as_deref().unwrap_or("")));
                    if let Some(threshold) = metric.threshold {
                        md.push_str(&format!(" (threshold: {})", threshold));
                    }
                    md.push('\n');
                }
                md.push('\n');
            }
            
            // Log evidence
            if !finding.evidence.logs.is_empty() {
                md.push_str("**Log Entries:**\n\n");
                for log in finding.evidence.logs.iter().take(3) {
                    md.push_str(&format!("- **{}** ({}x): `{}`\n", 
                                       log.level, 
                                       log.count,
                                       log.message.chars().take(100).collect::<String>()));
                }
                if finding.evidence.logs.len() > 3 {
                    md.push_str(&format!("- _{} more log entries..._\n", finding.evidence.logs.len() - 3));
                }
                md.push('\n');
            }
        }
        
        // Remediation
        if !finding.remediation.steps.is_empty() {
            md.push_str("#### Remediation Steps\n\n");
            
            for step in &finding.remediation.steps {
                md.push_str(&format!("{}. {}\n", step.order, step.description));
                if let Some(cmd) = &step.command {
                    md.push_str(&format!("   ```bash\n   {}\n   ```\n", cmd));
                }
                if let Some(verification) = &step.verification {
                    md.push_str(&format!("   - **Verify**: {}\n", verification));
                }
            }
            md.push('\n');
            
            // Remediation metadata
            md.push_str("**Remediation Details:**\n\n");
            md.push_str(&format!("- **Risk Level**: {}\n", self.format_risk_level(finding.remediation.risk_level)));
            md.push_str(&format!("- **Requires Downtime**: {}\n", 
                              if finding.remediation.requires_downtime { "Yes ‚ö†Ô∏è" } else { "No ‚úÖ" }));
            if let Some(duration) = finding.remediation.estimated_duration_minutes {
                md.push_str(&format!("- **Estimated Duration**: {} minutes\n", duration));
            }
            if let Some(rollback) = &finding.remediation.rollback_plan {
                md.push_str(&format!("- **Rollback Plan**: {}\n", rollback));
            }
            md.push('\n');
        }
        
        md.push_str("---\n\n");
        
        Ok(())
    }

    fn count_severities(&self, findings: &[Finding]) -> (usize, usize, usize, usize, usize) {
        let critical = findings.iter().filter(|f| f.severity == Severity::Critical).count();
        let high = findings.iter().filter(|f| f.severity == Severity::High).count();
        let medium = findings.iter().filter(|f| f.severity == Severity::Medium).count();
        let low = findings.iter().filter(|f| f.severity == Severity::Low).count();
        let info = findings.iter().filter(|f| f.severity == Severity::Info).count();
        (critical, high, medium, low, info)
    }

    fn count_categories(&self, findings: &[Finding]) -> Vec<(Category, usize)> {
        let mut result = vec![];
        
        // Count each category type manually
        let categories = [
            Category::ClusterHygiene,
            Category::Performance,
            Category::Configuration,
            Category::Security,
            Category::Availability,
            Category::Client,
            Category::Capacity,
            Category::Other,
        ];
        
        for category in categories {
            let count = findings.iter().filter(|f| std::mem::discriminant(&f.category) == std::mem::discriminant(&category)).count();
            if count > 0 {
                result.push((category, count));
            }
        }
        
        result.sort_by(|a, b| b.1.cmp(&a.1));
        result
    }

    fn format_category(&self, category: Category) -> &'static str {
        match category {
            Category::ClusterHygiene => "Cluster Hygiene",
            Category::Performance => "Performance",
            Category::Configuration => "Configuration",
            Category::Security => "Security",
            Category::Availability => "Availability",
            Category::Client => "Client",
            Category::Capacity => "Capacity",
            Category::Other => "Other",
        }
    }

    fn format_risk_level(&self, risk: RiskLevel) -> &'static str {
        match risk {
            RiskLevel::Low => "Low üü¢",
            RiskLevel::Medium => "Medium üü°",
            RiskLevel::High => "High üî¥",
        }
    }

    fn calculate_health_score(&self, findings: &[Finding]) -> f64 {
        let mut score = 100.0;
        
        for finding in findings {
            let penalty = match finding.severity {
                Severity::Critical => 25.0,
                Severity::High => 15.0,
                Severity::Medium => 8.0,
                Severity::Low => 3.0,
                Severity::Info => 0.0,
            };
            score -= penalty;
        }
        
        f64::max(score, 0.0)
    }
}

impl ReportGenerator for MarkdownReporter {
    fn generate(&self, snapshot: &Snapshot, output_path: &Path) -> ReportResult<()> {
        self.save_report(snapshot, &snapshot.findings, output_path)
    }
    
    fn name(&self) -> &'static str {
        "markdown"
    }
}

impl Default for MarkdownReporter {
    fn default() -> Self {
        Self::new()
    }
}
